#![feature(array_map)]

use std::{env, fs};
use std::path::PathBuf;

struct FnDesc<'a> {
    sig: &'a str,
    name: &'a str,
    ty: &'a str,
    arg: u32,
    num: &'a str,
    is_syscall: bool,
}

fn parse_fn_desc(fn_desc: &str) -> FnDesc {
    let is_syscall = fn_desc.chars().nth(0) == Some('S');
    let mut type_end = 1;
    let mut num_start = 2;
    let mut num_end = 4;
    let mut sig_start = 7;
    let mut arg = 9;
    if is_syscall {
        type_end += 2;
        num_start += 2;
        num_end += 2;
        sig_start += 2;
        arg = 4;
    };
    let ty = &fn_desc[0..type_end];
    let num = &fn_desc[num_start..num_end];
    let sig = &fn_desc[sig_start..];
    let name = sig.split('(').next().unwrap();
    FnDesc {
        sig,
        name,
        ty,
        arg,
        num,
        is_syscall,
    }
}

const INDENT: &'static str = "    ";

fn decl_bios_fn(func: &FnDesc) -> String {
    format!("{}/// [BIOS Function {}({}h)](http://problemkaputt.de/psx-spx.htm#biosfunctionsummary)\n\
             {0}pub fn {3}\n", INDENT, func.ty, func.num, func.sig)
}

fn mk_bios_trampoline(func: &FnDesc) -> String {
    let li_stmt = &format!("li ${}, 0x{}", func.arg, func.num);
    let j_stmt = &if func.is_syscall {
        "syscall 0x0".to_string()
    } else {
        format!("j 0x{}0", func.ty)
    };
    let stmts = if func.is_syscall {
        [li_stmt, j_stmt]
    } else {
        [j_stmt, li_stmt]
    };
    format!("\n\
             .globl {}\n\
             {0}:\n\
                 {}{}\n\
                 {1}{3}\n", func.name, INDENT, stmts[0], stmts[1])
}

fn main() {
    let bios_functions = [
        "A(00h) file_open(filename: *const u8, accessmode: u32) -> u8;",
        "A(06h) exit(exitcode: i32);",
        "A(13h) save_state(buf: *mut u8);",
        //"A(14h) restore_state(buf: *mut u8, param:);",

        "A(2Fh) rand() -> i16;",

        "A(30h) srand(seed: u32);",
        "A(33h) malloc(size: usize) -> *mut u8;",
        "A(34h) free(buf: *mut u8);",
        "A(37h) calloc(sizex: usize, sizey: usize) -> *const u8;",
        "A(38h) realloc(old_buf: *const u8, new_size: usize);",
        "A(39h) init_heap(addr: usize, size: usize);",
        "A(3Ah) system_error_exit(exitcode: i32);",
        "A(3Fh) printf(msg: *const u8, ...);",

        "A(41h) load_exe_header(filename: *const u8, headerbuf: *mut u8);",
        "A(42h) load_exe_file(filename: *const u8, headerbuf: *mut u8);",
        "A(43h) do_execute(headerbuf: *mut u8, param1: u32, param2: u32);",
        "A(44h) flush_cache();",
        "A(47h) gpu_send_dma(xdst: u16, ydst: u16, xsiz: u16, ysize: u16, src: u32);",
        "A(48h) gpu_gp1_command_word(cmd: u32);",
        "A(49h) gpu_command_word(cmd: u32);",
        "A(4Ah) gpu_command_word_params(src: *const u32, num: usize);",
        "A(4Dh) gpu_get_status() -> u32;",

        "A(51h) load_and_execute(filename: *const u8, stackbase: u32, stackoffset: u32);",

        "A(72h) cd_remove();",
        "A(A0h) warm_boot();",

        "B(12h) init_pad(buf1: *mut u8, siz1: usize, buf2: *mut u8, siz2: usize);",
        "B(13h) start_pad();",
        "B(14h) stop_pad();",
        "B(5Bh) change_clear_pad(int: u32);",

        "C(0Ah) change_clear_rcnt(t: u32, flag: u32);",
        "C(13h) flush_std_in_out_put();",

        "SYS(01h) enter_critical_section() -> u8;",
        "SYS(02h) exit_critical_section();",
    ].map(|desc| parse_fn_desc(desc));

    // Generate the bios function trampolines
    let asm_file = "src/bios/trampoline.s";
    let asm = bios_functions
        .iter()
        .fold(String::new(), |s, f| s + &mk_bios_trampoline(f));
    fs::write(asm_file,
        format!("// This file was automatically generated by build.rs\n\
                 .set noreorder\n{}", asm))
        .expect(&format!("Unable to write to {}", asm_file));

    // Generate the bios function declarations
    let src_file = "src/bios/kernel.rs";
    let src = bios_functions.iter().fold(String::new(), |s, f| s + &decl_bios_fn(f));
    fs::write(src_file,
        format!("//! BIOS kernel functions\n\
                 // This file was automatically generated by build.rs\n\n\
                 global_asm!(include_str!(\"trampoline.s\"));\n\n\
                 extern \"C\" {{\n\
                 {}\
                 }}", src))
        .expect(&format!("Unable to write to {}", src_file));

    // Put the linker script to somewhere accessible
    let out = &PathBuf::from(env::var_os("OUT_DIR").unwrap());
    let linker_script = include_str!("psexe.ld").to_string();
    fs::write(out.join("psexe.ld"), linker_script).unwrap();
    println!("cargo:rustc-link-search={}", out.display());
}
